name: Extract Files Used in Test

on:
  workflow_dispatch:
    inputs:
      test_posix:
        description: "Ruta del archivo de prueba .api.cy.ts"
        required: true
        default: "cypress/e2e/Tests/API/Cards/GX3-5811-boardMembers.api.cy.ts"
        type: string

jobs:
  extract_files:
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v2

      - name: Validar entrada de archivo de prueba
        id: validate-input
        run: |
          TEST_POSIX="${{ inputs.test_posix }}"
          if [[ ! -f "$TEST_POSIX" ]]; then
            echo "El archivo especificado no existe: $TEST_POSIX"
            exit 1
          fi
          echo "Archivo de prueba validado: $TEST_POSIX"

      - name: Buscar referencias en el archivo de prueba
        id: find-imports
        run: |
          TEST_POSIX="${{ inputs.test_posix }}"
          
          # Ruta al archivo de configuración de alias
          ALIAS_CONFIG_PATH="./.eslintrc.json"

          # Cargar los alias desde el archivo de configuración (.eslintrc.json)
          declare -A alias_map

          # Extraer alias y sus rutas desde el archivo .eslintrc.json
          while IFS= read -r line; do
            alias_name=$(echo "$line" | jq -r '.key')
            real_path=$(echo "$line" | jq -r '.value[0]')
            alias_map["$alias_name"]="$real_path"
          done < <(jq -r '.settings["import/resolver"].alias.map | to_entries | .[] | {key: .key, value: .value}' "$ALIAS_CONFIG_PATH")

          # Función para resolver alias y rutas relativas
          resolve_path() {
            local path=$1

            # Resolver alias
            for alias_name in "${!alias_map[@]}"; do
              if [[ "$path" == $alias_name* ]]; then
                path="${alias_map[$alias_name]}${path#$alias_name}"
                break
              fi
            done

            # Resolver rutas relativas (./, ../)
            if [[ "$path" == ./.* ]]; then
              path="./$(realpath --relative-to="$(pwd)" "$path")"
            elif [[ "$path" == ../* ]]; then
              path="../$(realpath --relative-to="$(pwd)" "$path")"
            fi

            echo "$path"
          }

          # Buscar sentencias import que terminan con ;
          FILE_REFERENCES=$(grep -Eo 'import\s+.*\s+from\s+["'\''][^"'\'' ]+["'\''];' "$TEST_POSIX" || echo "")

          # Si se encuentran referencias, procesarlas
          if [[ -n "$FILE_REFERENCES" ]]; then
            RESOLVED_FILES=""
            
            # Procesar cada línea que contiene una referencia de importación
            while IFS= read -r file; do
              # Extraer solo la ruta después de "from"
              path=$(echo "$file" | sed -E 's/.*from\s+["'\'']([^"'\'']+)["'\''];/\1/')
              resolved_path=$(resolve_path "$path")

              # Filtrar solo rutas dentro de la carpeta cypress/
              if [[ "$resolved_path" == cypress/* ]]; then
                RESOLVED_FILES+="$resolved_path"$'\n'
              fi
            done <<< "$FILE_REFERENCES"

            # Eliminar líneas vacías de RESOLVED_FILES
            RESOLVED_FILES=$(echo "$RESOLVED_FILES" | grep -v '^\s*$')

            # Generar el JSON con las rutas
            JSON_OUTPUT=$(echo "$RESOLVED_FILES" | sort | uniq | jq -Rn --arg source "$TEST_POSIX" '{source: $source, files: [inputs | split("\n")[] | select(length > 0)]}')
            echo "$JSON_OUTPUT"
          fi

