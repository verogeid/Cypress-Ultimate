name: Extract Files Used in Test

on:
  workflow_dispatch:
    inputs:
      test_posix:
        description: "Ruta del archivo de prueba .api.cy.ts"
        required: true
        default: "cypress/e2e/Tests/API/Cards/GX3-5811-boardMembers.api.cy.ts"
        type: string

jobs:
  extract_files:
    runs-on: ubuntu-latest
    steps:
      # Paso 1: Descargar el código del repositorio
      - name: Check out code
        uses: actions/checkout@v2

      # Paso 2: Validar que el archivo de prueba existe
      - name: Validar entrada de archivo de prueba
        id: validate-input
        run: |
          TEST_POSIX="${{ inputs.test_posix }}"
          # Verifica si el archivo de prueba especificado existe
          if [[ ! -f "$TEST_POSIX" ]]; then
            echo "El archivo especificado no existe: $TEST_POSIX"
            exit 1  # Termina el flujo si no existe el archivo
          fi
          echo "Archivo de prueba validado: $TEST_POSIX"

      # Paso 3: Leer el archivo .eslintrc.json y extraer los alias definidos para resolver rutas
      - name: Parse ESLint Config y Extraer Aliases
        id: extract-aliases
        run: |
          if [[ ! -f ".eslintrc.json" ]]; then
            echo "Archivo .eslintrc.json no encontrado"
            exit 1  # Termina el flujo si no existe el archivo .eslintrc.json
          fi

          # Extrae los alias desde el archivo .eslintrc.json usando jq
          ALIAS_MAP=$(jq -r '.settings["import/resolver"].alias.map[] | @csv' .eslintrc.json | sed 's/"//g' || echo "")

          # Si no se encuentran alias, se muestra un mensaje, pero el flujo sigue adelante
          if [[ -z "$ALIAS_MAP" ]]; then
            echo "No se encontraron alias en .eslintrc.json, continuando sin resolver rutas de alias."
          else
            echo "Aliases encontrados:"
            echo "$ALIAS_MAP"

            # Para cada alias encontrado, lo exporta como una variable de entorno
            echo "$ALIAS_MAP" | while IFS=',' read -r alias path; do
              echo "$alias=$path" >> $GITHUB_ENV
            done
          fi

      # Paso 4: Buscar las referencias a archivos en las sentencias import y cy.fixture
      - name: Buscar referencias en el archivo de prueba
        id: find-imports
        run: |
          TEST_POSIX="${{ inputs.test_posix }}"

          # Mostrar el contenido del archivo de prueba para depuración
          echo "Contenido del archivo de prueba:"
          cat "$TEST_POSIX"

          # Buscar todas las sentencias import y cy.fixture en el archivo de prueba
          FILE_REFERENCES=$(grep -Eo '(import .* from|cy\.fixture(..*).)' "$TEST_POSIX" | grep -Eo '"[^"]+"' | tr -d '"' || echo "")

          # Si no se encuentran referencias, termina el flujo
          if [[ -z "$FILE_REFERENCES" ]]; then
            echo "No se encontraron referencias en el archivo de prueba."
            exit 1
          fi

          echo "Referencias encontradas:"
          echo "$FILE_REFERENCES"

          # Paso 5: Resolver las rutas de los archivos utilizando los alias y las rutas relativas
          RESOLVED_FILES=""
          while IFS= read -r file; do
            # Si la ruta comienza con un alias, lo resolvemos
            if [[ "$file" == @* ]]; then
              alias=$(echo "$file" | cut -d/ -f1)  # Extrae el alias
              path=$(echo "$file" | cut -d/ -f2-)  # Extrae la ruta después del alias
              # Evalúa la variable de entorno del alias para obtener la ruta real
              real_path=$(eval echo "\$$alias")/$path
              RESOLVED_FILES+="$real_path"$'\n'
            # Si la ruta comienza con 'cypress/', la dejamos tal como está
            elif [[ "$file" == cypress/* ]]; then
              RESOLVED_FILES+="$file"$'\n'
            else
              # Si la ruta no tiene alias, la mantenemos tal cual está
              RESOLVED_FILES+="$file"$'\n'
            fi
          done <<< "$FILE_REFERENCES"

          # Elimina rutas duplicadas y guarda las rutas resueltas en un archivo temporal
          echo "$RESOLVED_FILES" | sort | uniq > resolved_files.txt
          echo "Rutas resueltas:"
          cat resolved_files.txt

      # Paso 6: Crear un archivo JSON con las rutas resueltas
      - name: Crear JSON con rutas de archivos
        run: |
          # Convierte las rutas resueltas en un archivo JSON con la estructura { "files": [...] }
          jq -Rn 'inputs | split("\n") | map(select(length > 0)) | {files: .}' < resolved_files.txt > resolved_files.json
          echo "Archivo JSON generado:"
          cat resolved_files.json

      # Paso 7: Subir el archivo JSON generado como un artefacto
      - name: Guardar JSON como artefacto
        uses: actions/upload-artifact@v3
        with:
          name: resolved-files
          path: resolved_files.json

